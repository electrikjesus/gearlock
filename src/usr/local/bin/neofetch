#!/usr/bin/env bash
version=7.1.0
bash_version=${BASH_VERSINFO[0]:-5}
shopt -s eval_unsafe_arith &>/dev/null
sys_locale=${LANG:-C}
XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-${HOME}/.config}
PATH=$PATH:/usr/xpg4/bin:/usr/sbin:/sbin:/usr/etc:/usr/libexec
reset='\e[0m'
shopt -s nocasematch
LC_ALL=C
LANG=C
export GIO_EXTRA_MODULES=/usr/lib/x86_64-linux-gnu/gio/modules/
get_os() {
os=Linux
}
get_distro() {
[[ $distro ]] && return
distro="Android $(getprop ro.build.version.release)"
case $os in
Solaris|AIX|Haiku|IRIX|FreeMiNT)
machine_arch=$(uname -p)
;;
*)  machine_arch=$kernel_machine ;;
esac
[[ $os_arch == on ]] && \
distro+=" $machine_arch"
[[ ${ascii_distro:-auto} == auto ]] && \
ascii_distro=$(trim "$distro")
}
get_model() {
model="$(getprop ro.product.brand) $(getprop ro.product.model)"
}
get_title() {
user=${USER:-$(id -un || printf %s "${HOME/*\/}")}
case $title_fqdn in
on) hostname=$(hostname -f) ;;
*)  hostname=${HOSTNAME:-$(hostname)} ;;
esac
title=${title_color}${bold}${user}${at_color}@${title_color}${bold}${hostname}
length=$((${#user} + ${#hostname} + 1))
}
get_kernel() {
case $kernel_shorthand in
on)  kernel=$kernel_version ;;
off) kernel="$kernel_name $kernel_version" ;;
esac
}
get_uptime() {
if [[ -r /proc/uptime ]]; then
s=$(< /proc/uptime)
s=${s/.*}
else
boot=$(date -d"$(uptime -s)" +%s)
now=$(date +%s)
s=$((now - boot))
fi
d="$((s / 60 / 60 / 24)) days"
h="$((s / 60 / 60 % 24)) hours"
m="$((s / 60 % 60)) minutes"
((${d/ *} == 1)) && d=${d/s}
((${h/ *} == 1)) && h=${h/s}
((${m/ *} == 1)) && m=${m/s}
((${d/ *} == 0)) && unset d
((${h/ *} == 0)) && unset h
((${m/ *} == 0)) && unset m
uptime=${d:+$d, }${h:+$h, }$m
uptime=${uptime%', '}
uptime=${uptime:-$s seconds}
case $uptime_shorthand in
on)
uptime=${uptime/ minutes/ mins}
uptime=${uptime/ minute/ min}
uptime=${uptime/ seconds/ secs}
;;
tiny)
uptime=${uptime/ days/d}
uptime=${uptime/ day/d}
uptime=${uptime/ hours/h}
uptime=${uptime/ hour/h}
uptime=${uptime/ minutes/m}
uptime=${uptime/ minute/m}
uptime=${uptime/ seconds/s}
uptime=${uptime//,}
;;
esac
}
get_packages() {
pkgs_h=0
has() { type -p "$1" >/dev/null && manager=$1; }
pac() { (($1 > 0)) && { managers+=("$1 (${manager})"); manager_string+="${manager}, "; }; }
tot() {
IFS=$'\n' read -d "" -ra pkgs <<< "$("$@")";
((packages+=${#pkgs[@]}));
pac "$((${#pkgs[@]}-pkgs_h))";
}
has apk && tot apk info
has pm && tot pm list package
if ((packages == 0)); then
unset packages
elif [[ $package_managers == on ]]; then
printf -v packages '%s, ' "${managers[@]}"
packages=${packages%,*}
fi
}
get_shell() {
case $shell_path in
on)  shell="$SHELL " ;;
off) shell="${SHELL##*/} " ;;
esac
[[ $shell_version != on ]] && return
case ${shell_name:=${SHELL##*/}} in
bash)
[[ $BASH_VERSION ]] ||
BASH_VERSION=$("$SHELL" -c "printf %s \"\$BASH_VERSION\"")
shell+=${BASH_VERSION/-*}
;;
sh|ash|dash|es) ;;
*ksh)
shell+=$("$SHELL" -c "printf %s \"\$KSH_VERSION\"")
shell=${shell/ * KSH}
shell=${shell/version}
;;
osh)
if [[ $OIL_VERSION ]]; then
shell+=$OIL_VERSION
else
shell+=$("$SHELL" -c "printf %s \"\$OIL_VERSION\"")
fi
;;
tcsh)
shell+=$("$SHELL" -c "printf %s \$tcsh")
;;
yash)
shell+=$("$SHELL" --version 2>&1)
shell=${shell/ $shell_name}
shell=${shell/ Yet another shell}
shell=${shell/Copyright*}
;;
nu)
shell+=$("$SHELL" -c "version | get version")
shell=${shell/ $shell_name}
;;
*)
shell+=$("$SHELL" --version 2>&1)
shell=${shell/ $shell_name}
;;
esac
shell=${shell/, version}
shell=${shell/xonsh\//xonsh }
shell=${shell/options*}
shell=${shell/\(*\)}
}
get_de() {
((de_run == 1)) && return
((wm_run != 1)) && get_wm
if [[ $DESKTOP_SESSION == *regolith ]]; then
de=Regolith
elif [[ $XDG_CURRENT_DESKTOP ]]; then
de=${XDG_CURRENT_DESKTOP/X\-}
de=${de/Budgie:GNOME/Budgie}
de=${de/:Unity7:ubuntu}
elif [[ $DESKTOP_SESSION ]]; then
de=${DESKTOP_SESSION##*/}
elif [[ $GNOME_DESKTOP_SESSION_ID ]]; then
de=GNOME
elif [[ $MATE_DESKTOP_SESSION_ID ]]; then
de=MATE
elif [[ $TDE_FULL_SESSION ]]; then
de=Trinity
fi
[[ $de == "$wm" ]] && { unset -v de; return; }
[[ $DISPLAY && -z $de ]] && type -p xprop &>/dev/null && \
de=$(xprop -root | awk '/KDE_SESSION_VERSION|^_MUFFIN|xfce4|xfce5/')
case $de in
KDE_SESSION_VERSION*) de=KDE${de/* = } ;;
*xfce4*)  de=Xfce4 ;;
*xfce5*)  de=Xfce5 ;;
*xfce*)   de=Xfce ;;
*mate*)   de=MATE ;;
*GNOME*)  de=GNOME ;;
*MUFFIN*) de=Cinnamon ;;
esac
((${KDE_SESSION_VERSION:-0} >= 4)) && de=${de/KDE/Plasma}
if [[ $de_version == on && $de ]]; then
case $de in
Plasma*)   de_ver=$(plasmashell --version) ;;
MATE*) de_ver=$(mate-session --version) ;;
Xfce*) de_ver=$(xfce4-session --version) ;;
GNOME*)de_ver=$(gnome-shell --version) ;;
Cinnamon*) de_ver=$(cinnamon --version) ;;
Deepin*)   de_ver=$(awk -F'=' '/MajorVersion/ {print $2}' /etc/os-version) ;;
Budgie*)   de_ver=$(budgie-desktop --version) ;;
LXQt*) de_ver=$(lxqt-session --version) ;;
Lumina*)   de_ver=$(lumina-desktop --version 2>&1) ;;
Trinity*)  de_ver=$(tde-config --version) ;;
Unity*)de_ver=$(unity --version) ;;
esac
de_ver=${de_ver/*TDE:}
de_ver=${de_ver/tde-config*}
de_ver=${de_ver/liblxqt*}
de_ver=${de_ver/Copyright*}
de_ver=${de_ver/)*}
de_ver=${de_ver/* }
de_ver=${de_ver//\"}
de+=" $de_ver"
fi
[[ $de && $WAYLAND_DISPLAY ]] &&
de+=" (Wayland)"
de_run=1
}
get_wm() {
((wm_run == 1)) && return
ps_flags=(-e)
if [[ -O "${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY:-wayland-0}" ]]; then
if tmp_pid="$(lsof -t "${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY:-wayland-0}" 2>&1)" ||
 tmp_pid="$(fuser   "${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY:-wayland-0}" 2>&1)"; then
wm="$(ps -p "${tmp_pid}" -ho comm=)"
else
wm=$(ps "${ps_flags[@]}" | grep -m 1 -o -F \
 -e arcan \
 -e asc \
 -e clayland \
 -e dwc \
 -e fireplace \
 -e gnome-shell \
 -e greenfield \
 -e grefsen \
 -e hikari \
 -e kwin \
 -e lipstick \
 -e maynard \
 -e mazecompositor \
 -e motorcar \
 -e orbital \
 -e orbment \
 -e perceptia \
 -e river \
 -e rustland \
 -e sway \
 -e ulubis \
 -e velox \
 -e wavy \
 -e way-cooler \
 -e wayfire \
 -e wayhouse \
 -e westeros \
 -e westford \
 -e weston)
fi
elif [[ $DISPLAY && $os != "Mac OS X" && $os != "macOS" && $os != FreeMiNT ]]; then
wm=$(ps "${ps_flags[@]}" | grep -m 1 -o \
 -e "[s]owm" \
 -e "[c]atwm" \
 -e "[f]vwm" \
 -e "[d]wm" \
 -e "[2]bwm" \
 -e "[m]onsterwm" \
 -e "[t]inywm" \
 -e "[x]11fs" \
 -e "[x]monad")
[[ -z $wm ]] && type -p xprop &>/dev/null && {
id=$(xprop -root -notype _NET_SUPPORTING_WM_CHECK)
id=${id##* }
wm=$(xprop -id "$id" -notype -len 100 -f _NET_WM_NAME 8t)
wm=${wm/*WM_NAME = }
wm=${wm/\"}
wm=${wm/\"*}
}
fi
[[ $wm == *WINDOWMAKER* ]] && wm=wmaker
[[ $wm == *GNOME*Shell* ]] && wm=Mutter
wm_run=1
}
get_wm_theme() {
((wm_run != 1)) && get_wm
((de_run != 1)) && get_de
case $wm  in
E16)
wm_theme=$(awk -F "= " '/theme.name/ {print $2}' "${HOME}/.e16/e_config--0.0.cfg")
;;
Sawfish)
wm_theme=$(awk -F '\\(quote|\\)' '/default-frame-style/ {print $(NF-4)}' \
 "$HOME/.sawfish/custom")
;;
Cinnamon|Muffin|"Mutter (Muffin)")
detheme=$(gsettings get org.cinnamon.theme name)
wm_theme=$(gsettings get org.cinnamon.desktop.wm.preferences theme)
wm_theme="$detheme ($wm_theme)"
;;
Compiz|Mutter|Gala)
if type -p gsettings >/dev/null; then
wm_theme=$(gsettings get org.gnome.shell.extensions.user-theme name)
[[ ${wm_theme//\'} ]] || \
wm_theme=$(gsettings get org.gnome.desktop.wm.preferences theme)
elif type -p gconftool-2 >/dev/null; then
wm_theme=$(gconftool-2 -g /apps/metacity/general/theme)
fi
;;
Metacity*)
if [[ $de == Deepin ]]; then
wm_theme=$(gsettings get com.deepin.wrap.gnome.desktop.wm.preferences theme)
elif [[ $de == MATE ]]; then
wm_theme=$(gsettings get org.mate.Marco.general theme)
else
wm_theme=$(gconftool-2 -g /apps/metacity/general/theme)
fi
;;
E17|Enlightenment)
if type -p eet >/dev/null; then
wm_theme=$(eet -d "$HOME/.e/e/config/standard/e.cfg" config |\
awk '/value \"file\" string.*.edj/ {print $4}')
wm_theme=${wm_theme##*/}
wm_theme=${wm_theme%.*}
fi
;;
Fluxbox)
[[ -f $HOME/.fluxbox/init ]] &&
wm_theme=$(awk -F "/" '/styleFile/ {print $NF}' "$HOME/.fluxbox/init")
;;
IceWM*)
[[ -f $HOME/.icewm/theme ]] &&
wm_theme=$(awk -F "[\",/]" '!/#/ {print $2}' "$HOME/.icewm/theme")
;;
Openbox)
case $de in
LXDE*) ob_file=lxde-rc ;;
LXQt*) ob_file=lxqt-rc ;;
*) ob_file=rc ;;
esac
ob_file=$XDG_CONFIG_HOME/openbox/$ob_file.xml
[[ -f $ob_file ]] &&
wm_theme=$(awk '/<theme>/ {while (getline n) {if (match(n, /<name>/))
{l=n; exit}}} END {split(l, a, "[<>]"); print a[3]}' "$ob_file")
;;
PekWM)
[[ -f $HOME/.pekwm/config ]] &&
wm_theme=$(awk -F "/" '/Theme/{gsub(/\"/,""); print $NF}' "$HOME/.pekwm/config")
;;
Xfwm4)
[[ -f $HOME/.config/xfce4/xfconf/xfce-perchannel-xml/xfwm4.xml ]] &&
wm_theme=$(xfconf-query -c xfwm4 -p /general/theme)
;;
KWin*)
kde_config_dir
kwinrc=$kde_config_dir/kwinrc
kdebugrc=$kde_config_dir/kdebugrc
if [[ -f $kwinrc ]]; then
wm_theme=$(awk '/theme=/ {
gsub(/theme=.*qml_|theme=.*svg__/,"",$0);
print $0;
exit
 }' "$kwinrc")
[[ "$wm_theme" ]] ||
wm_theme=$(awk '/library=org.kde/ {
gsub(/library=org.kde./,"",$0);
print $0;
exit
 }' "$kwinrc")
[[ $wm_theme ]] ||
wm_theme=$(awk '/PluginLib=kwin3_/ {
gsub(/PluginLib=kwin3_/,"",$0);
print $0;
exit
 }' "$kwinrc")
elif [[ -f $kdebugrc ]]; then
wm_theme=$(awk '/(decoration)/ {gsub(/\[/,"",$1); print $1; exit}' "$kdebugrc")
fi
wm_theme=${wm_theme/theme=}
;;
"Quartz Compositor")
global_preferences=$HOME/Library/Preferences/.GlobalPreferences.plist
wm_theme=$(PlistBuddy -c "Print AppleInterfaceStyle" "$global_preferences")
wm_theme_color=$(PlistBuddy -c "Print AppleAccentColor" "$global_preferences")
[[ "$wm_theme" ]] ||
wm_theme=Light
case $wm_theme_color in
-1) wm_theme_color=Graphite ;;
0)  wm_theme_color=Red ;;
1)  wm_theme_color=Orange ;;
2)  wm_theme_color=Yellow ;;
3)  wm_theme_color=Green ;;
5)  wm_theme_color=Purple ;;
6)  wm_theme_color=Pink ;;
*)  wm_theme_color=Blue ;;
esac
wm_theme="$wm_theme_color ($wm_theme)"
;;
Blackbox|bbLean*)
path=$(wmic process get ExecutablePath | grep -F "blackbox")
path=${path//\\/\/}
wm_theme=$(grep '^session\.styleFile:' "${path/\.exe/.rc}")
wm_theme=${wm_theme/session\.styleFile: }
wm_theme=${wm_theme##*\\}
wm_theme=${wm_theme%.*}
;;
esac
wm_theme=$(trim_quotes "$wm_theme")
}
get_cpu() {
cpu_file="/proc/cpuinfo"
case $kernel_machine in
"frv" | "hppa" | "m68k" | "openrisc" | "or"* | "powerpc" | "ppc"* | "sparc"*)
cpu="$(awk -F':' '/^cpu\t|^CPU/ {printf $2; exit}' "$cpu_file")"
;;
"s390"*)
cpu="$(awk -F'=' '/machine/ {print $4; exit}' "$cpu_file")"
;;
"ia64" | "m32r")
cpu="$(awk -F':' '/model/ {print $2; exit}' "$cpu_file")"
[[ -z "$cpu" ]] && cpu="$(awk -F':' '/family/ {printf $2; exit}' "$cpu_file")"
;;
*)
cpu="$(awk -F '\\s*: | @' \
'/model name|Hardware|Processor|^cpu model|chip type|^cpu type/ {
cpu=$2; if ($1 == "Hardware") exit } END { print cpu }' "$cpu_file")"
;;
esac
speed_dir="/sys/devices/system/cpu/cpu0/cpufreq"
for temp_dir in /sys/class/hwmon/*; do
[[ "$(< "${temp_dir}/name")" =~ (cpu_thermal|coretemp|fam15h_power|k10temp) ]] && {
temp_dirs=("$temp_dir"/temp*_input)
temp_dir=${temp_dirs[0]}
break
}
done
if [[ -d "$speed_dir" ]]; then
speed="$(< "${speed_dir}/${speed_type}")" ||\
speed="$(< "${speed_dir}/bios_limit")" ||\
speed="$(< "${speed_dir}/scaling_max_freq")" ||\
speed="$(< "${speed_dir}/cpuinfo_max_freq")"
speed="$((speed / 1000))"
else
case $kernel_machine in
"sparc"*)
speed_file="/sys/devices/system/cpu/cpu0/clock_tick"
speed="$(($(< "$speed_file") / 1000000))"
;;
*)
speed="$(awk -F ': |\\.' '/cpu MHz|^clock/ {printf $2; exit}' "$cpu_file")"
speed="${speed/MHz}"
;;
esac
fi
[[ -f "$temp_dir" ]] && deg="$(($(< "$temp_dir") * 100 / 10000))"
case $kernel_machine in
"sparc"*)
case $cpu_cores in
"logical" | "on")
cores="$(lscpu | awk -F ': *' '/^CPU\(s\)/ {print $2}')"
;;
"physical")
cores="$(lscpu | awk -F ': *' '/^Core\(s\) per socket/ {print $2}')"
sockets="$(lscpu | awk -F ': *' '/^Socket\(s\)/ {print $2}')"
cores="$((sockets * cores))"
;;
esac
;;
*)
case $cpu_cores in
"logical" | "on")
cores="$(grep -c "^processor" "$cpu_file")"
;;
"physical")
cores="$(awk '/^core id/&&!a[$0]++{++i} END {print i}' "$cpu_file")"
;;
esac
;;
esac
cpu="${cpu//(TM)}"
cpu="${cpu//(tm)}"
cpu="${cpu//(R)}"
cpu="${cpu//(r)}"
cpu="${cpu//CPU}"
cpu="${cpu//Processor}"
cpu="${cpu//Dual-Core}"
cpu="${cpu//Quad-Core}"
cpu="${cpu//Six-Core}"
cpu="${cpu//Eight-Core}"
cpu="${cpu//[1-9][0-9]-Core}"
cpu="${cpu//[0-9]-Core}"
cpu="${cpu//, * Compute Cores}"
cpu="${cpu//Core / }"
cpu="${cpu//(\"AuthenticAMD\"*)}"
cpu="${cpu//with Radeon * Graphics}"
cpu="${cpu//, altivec supported}"
cpu="${cpu//FPU*}"
cpu="${cpu//Chip Revision*}"
cpu="${cpu//Technologies, Inc}"
cpu="${cpu//Core2/Core 2}"
cores="${cores//[[:space:]]}"
speed="${speed//[[:space:]]}"
if [[ "$cpu_brand" == "off" ]]; then
cpu="${cpu/AMD }"
cpu="${cpu/Intel }"
cpu="${cpu/Core? Duo }"
cpu="${cpu/Qualcomm }"
fi
[[ "$cpu_cores" != "off" && "$cores" ]] && \
case $os in
*)  cpu="$cpu ($cores)" ;;
esac
if [[ "$cpu_speed" != "off" && "$speed" ]]; then
if (( speed < 1000 )); then
cpu="$cpu @ ${speed}MHz"
else
[[ "$speed_shorthand" == "on" ]] && speed="$((speed / 100))"
speed="${speed:0:1}.${speed:1}"
cpu="$cpu @ ${speed}GHz"
fi
fi
if [[ "$cpu_temp" != "off" && "$deg" ]]; then
deg="${deg//.}"
[[ "$cpu_temp" == "F" ]] && deg="$((deg * 90 / 50 + 320))"
deg="[${deg/${deg: -1}}.${deg: -1}°${cpu_temp:-C}]"
cpu="$cpu $deg"
fi
}
get_gpu() {
gpu_cmd="$(lspci -mm |
awk -F '\"|\" \"|\\(' \
'/"Display|"3D|"VGA/ {
a[$0] = $1 " " $3 " " ($(NF-1) ~ /^$|^Device [[:xdigit:]]+$/ ? $4 : $(NF-1))
}
END { for (i in a) {
if (!seen[a[i]]++) {
sub("^[^ ]+ ", "", a[i]);
print a[i]
}
}}')"
IFS=$'\n' read -d "" -ra gpus <<< "$gpu_cmd"
#
[[ "${gpus[0]}" == *Intel* && "${gpus[1]}" == *Intel* ]] && unset -v "gpus[0]"
for gpu in "${gpus[@]}"; do
[[ "$gpu_type" == "dedicated" && "$gpu" == *Intel* ]] || \
[[ "$gpu_type" == "integrated" && ! "$gpu" == *Intel* ]] && \
{ unset -v gpu; continue; }
case $gpu in
*"Advanced"*)
brand="${gpu/*AMD*ATI*/AMD ATI}"
brand="${brand:-${gpu/*AMD*/AMD}}"
brand="${brand:-${gpu/*ATI*/ATi}}"
gpu="${gpu/\[AMD\/ATI\] }"
gpu="${gpu/\[AMD\] }"
gpu="${gpu/OEM }"
gpu="${gpu/Advanced Micro Devices, Inc.}"
gpu="${gpu/*\[}"
gpu="${gpu/\]*}"
gpu="$brand $gpu"
;;
*"NVIDIA"*)
gpu="${gpu/*\[}"
gpu="${gpu/\]*}"
gpu="NVIDIA $gpu"
;;
*"Intel"*)
gpu="${gpu/*Intel/Intel}"
gpu="${gpu/\(R\)}"
gpu="${gpu/Corporation}"
gpu="${gpu/ \(*}"
gpu="${gpu/Integrated Graphics Controller}"
gpu="${gpu/*Xeon*/Intel HD Graphics}"
[[ -z "$(trim "$gpu")" ]] && gpu="Intel Integrated Graphics"
;;
*"MCST"*)
gpu="${gpu/*MCST*MGA2*/MCST MGA2}"
;;
*"VirtualBox"*)
gpu="VirtualBox Graphics Adapter"
;;
*) continue ;;
esac
if [[ "$gpu_brand" == "off" ]]; then
gpu="${gpu/AMD }"
gpu="${gpu/NVIDIA }"
gpu="${gpu/Intel }"
fi
prin "${subtitle:+${subtitle}${gpu_name}}" "$gpu"
done
if [[ "$gpu_brand" == "off" ]]; then
gpu="${gpu/AMD}"
gpu="${gpu/NVIDIA}"
gpu="${gpu/Intel}"
fi
}
get_memory() {
while IFS=":" read -r a b; do
case $a in
"MemTotal") ((mem_used+=${b/kB})); mem_total="${b/kB}" ;;
"Shmem") ((mem_used+=${b/kB}))  ;;
"MemFree" | "Buffers" | "Cached" | "SReclaimable")
mem_used="$((mem_used-=${b/kB}))"
;;
"MemAvailable")
mem_avail=${b/kB}
;;
esac
done < /proc/meminfo
if [[ $mem_avail ]]; then
mem_used=$(((mem_total - mem_avail) / 1024))
else
mem_used="$((mem_used / 1024))"
fi
mem_total="$((mem_total / 1024))"
[[ "$memory_percent" == "on" ]] && ((mem_perc=mem_used * 100 / mem_total))
case $memory_unit in
gib)
mem_used=$(awk '{printf "%.2f", $1 / $2}' <<< "$mem_used 1024")
mem_total=$(awk '{printf "%.2f", $1 / $2}' <<< "$mem_total 1024")
mem_label=GiB
;;
kib)
mem_used=$((mem_used * 1024))
mem_total=$((mem_total * 1024))
mem_label=KiB
;;
esac
memory="${mem_used}${mem_label:-MiB} / ${mem_total}${mem_label:-MiB} ${mem_perc:+(${mem_perc}%)}"
case $memory_display in
"bar") memory="$(bar "${mem_used}" "${mem_total}")" ;;
"infobar") memory="${memory} $(bar "${mem_used}" "${mem_total}")" ;;
"barinfo") memory="$(bar "${mem_used}" "${mem_total}")${info_color} ${memory}" ;;
esac
}
get_song() {
players=(
"amarok"
"audacious"
"banshee"
"bluemindo"
"clementine"
"cmus"
"deadbeef"
"deepin-music"
"dragon"
"elisa"
"exaile"
"gnome-music"
"gmusicbrowser"
"gogglesmm"
"guayadeque"
"io.elementary.music"
"iTunes"
"Music"
"juk"
"lollypop"
"MellowPlayer"
"mocp"
"mopidy"
"mpd"
"muine"
"netease-cloud-music"
"olivia"
"plasma-browser-integration"
"playerctl"
"pogo"
"pragha"
"qmmp"
"quodlibet"
"rhythmbox"
"sayonara"
"smplayer"
"spotify"
"Spotify"
"strawberry"
"tauonmb"
"tomahawk"
"vlc"
"xmms2d"
"xnoise"
"yarock"
)
printf -v players "|%s" "${players[@]}"
player="$(ps aux | awk -v pattern="(${players:1})" \
'!/ awk / && !/iTunesHelper/ && match($0,pattern){print substr($0,RSTART,RLENGTH); exit}')"
[[ "$music_player" && "$music_player" != "auto" ]] && player="$music_player"
get_song_dbus() {
song="$(\
dbus-send --print-reply --dest=org.mpris.MediaPlayer2."${1}" /org/mpris/MediaPlayer2 \
org.freedesktop.DBus.Properties.Get string:'org.mpris.MediaPlayer2.Player' \
string:'Metadata' |\
awk -F '"' 'BEGIN {RS=" entry"}; /"xesam:artist"/ {a = $4} /"xesam:album"/ {b = $4}
/"xesam:title"/ {t = $4} END {print a " \n" b " \n" t}'
)"
}
case ${player/*\/} in
"mocp"*)  song="$(mocp -Q '%artist \n%album \n%song')" ;;
"deadbeef"*)  song="$(deadbeef --nowplaying-tf '%artist% \\n%album% \\n%title%')" ;;
"qmmp"*)  song="$(qmmp --nowplaying '%p \n%a \n%t')" ;;
"gnome-music"*)   get_song_dbus "GnomeMusic" ;;
"lollypop"*)  get_song_dbus "Lollypop" ;;
"clementine"*)get_song_dbus "clementine" ;;
"cmus"*)  get_song_dbus "cmus" ;;
"juk"*)   get_song_dbus "juk" ;;
"bluemindo"*) get_song_dbus "Bluemindo" ;;
"guayadeque"*)get_song_dbus "guayadeque" ;;
"yarock"*)get_song_dbus "yarock" ;;
"deepin-music"*)  get_song_dbus "DeepinMusic" ;;
"tomahawk"*)  get_song_dbus "tomahawk" ;;
"elisa"*) get_song_dbus "elisa" ;;
"sayonara"*)  get_song_dbus "sayonara" ;;
"audacious"*) get_song_dbus "audacious" ;;
"vlc"*)   get_song_dbus "vlc" ;;
"gmusicbrowser"*) get_song_dbus "gmusicbrowser" ;;
"pragha"*)get_song_dbus "pragha" ;;
"amarok"*)get_song_dbus "amarok" ;;
"dragon"*)get_song_dbus "dragonplayer" ;;
"smplayer"*)  get_song_dbus "smplayer" ;;
"rhythmbox"*) get_song_dbus "rhythmbox" ;;
"strawberry"*)get_song_dbus "strawberry" ;;
"gogglesmm"*) get_song_dbus "gogglesmm" ;;
"xnoise"*)get_song_dbus "xnoise" ;;
"tauonmb"*)   get_song_dbus "tauon" ;;
"olivia"*)get_song_dbus "olivia" ;;
"exaile"*)get_song_dbus "exaile" ;;
"netease-cloud-music"*)get_song_dbus "netease-cloud-music" ;;
"plasma-browser-integration"*) get_song_dbus "plasma-browser-integration" ;;
"io.elementary.music"*)get_song_dbus "Music" ;;
"MellowPlayer"*)  get_song_dbus "MellowPlayer3" ;;
"mpd"* | "mopidy"*)
song="$(mpc -f '%artist% \n%album% \n%title%' current "${mpc_args[@]}")"
;;
"xmms2d"*)
song="$(xmms2 current -f "\${artist}"$' \n'"\${album}"$' \n'"\${title}")"
;;
"spotify"*)
case $os in
"Linux") get_song_dbus "spotify" ;;
"Mac OS X"|"macOS")
song="$(osascript -e 'tell application "Spotify" to artist of current track as¬
string & "\n" & album of current track as¬
string & "\n" & name of current track as string')"
;;
esac
;;
"itunes"*)
song="$(osascript -e 'tell application "iTunes" to artist of current track as¬
string & "\n" & album of current track as¬
string & "\n" & name of current track as string')"
;;
"music"*)
song="$(osascript -e 'tell application "Music" to artist of current track as¬
string & "\n" & album of current track as¬
string & "\n" & name of current track as string')"
;;
"banshee"*)
song="$(banshee --query-artist --query-album --query-title |\
awk -F':' '/^artist/ {a=$2} /^album/ {b=$2} /^title/ {t=$2}
 END {print a " \n" b " \n"t}')"
;;
"muine"*)
song="$(dbus-send --print-reply --dest=org.gnome.Muine /org/gnome/Muine/Player \
org.gnome.Muine.Player.GetCurrentSong |
awk -F':' '/^artist/ {a=$2} /^album/ {b=$2} /^title/ {t=$2}
 END {print a " \n" b " \n" t}')"
;;
"quodlibet"*)
song="$(dbus-send --print-reply --dest=net.sacredchao.QuodLibet \
/net/sacredchao/QuodLibet net.sacredchao.QuodLibet.CurrentSong |\
awk -F'"' 'BEGIN {RS=" entry"}; /"artist"/ {a=$4} /"album"/ {b=$4}
/"title"/ {t=$4} END {print a " \n" b " \n" t}')"
;;
"pogo"*)
song="$(dbus-send --print-reply --dest=org.mpris.pogo /Player \
org.freedesktop.MediaPlayer.GetMetadata |
awk -F'"' 'BEGIN {RS=" entry"}; /"artist"/ {a=$4} /"album"/ {b=$4}
/"title"/ {t=$4} END {print a " \n" b " \n" t}')"
;;
"playerctl"*)
song="$(playerctl metadata --format '{{ artist }} \n{{ album }} \n{{ title }}')"
 ;;
*) mpc &>/dev/null && song="$(mpc -f '%artist% \n%album% \n%title%' current)" || return ;;
esac
IFS=$'\n' read -d "" -r artist album title <<< "${song//'\n'/$'\n'}"
artist="$(trim "$artist")"
album="$(trim "$album")"
title="$(trim "$title")"
: "${artist:=Unknown Artist}" "${album:=Unknown Album}" "${title:=Unknown Song}"
if [[ "$song_shorthand" == "on" ]]; then
prin "Artist" "$artist"
prin "Album"  "$album"
prin "Song"   "$title"
else
song="${song_format/\%artist\%/$artist}"
song="${song/\%album\%/$album}"
song="${song/\%title\%/$title}"
fi
}
get_resolution() {
if type -p xrandr >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
case $refresh_rate in
"on")
resolution="$(xrandr --nograb --current |\
awk 'match($0,/[0-9]*\.[0-9]*\*/) {
printf $1 " @ " substr($0,RSTART,RLENGTH) "Hz, "}')"
;;
"off")
resolution="$(xrandr --nograb --current |\
awk -F 'connected |\\+|\\(' \
'/ connected.*[0-9]+x[0-9]+\+/ && $2 {printf $2 ", "}')"
resolution="${resolution/primary, }"
resolution="${resolution/primary }"
;;
esac
resolution="${resolution//\*}"
elif type -p xwininfo >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
read -r w h \
<<< "$(xwininfo -root | awk -F':' '/Width|Height/ {printf $2}')"
resolution="${w}x${h}"
elif type -p xdpyinfo >/dev/null && [[ $DISPLAY && -z $WAYLAND_DISPLAY ]]; then
resolution="$(xdpyinfo | awk '/dimensions:/ {printf $2}')"
elif [[ -d /sys/class/drm ]]; then
for dev in /sys/class/drm/*/modes; do
read -r single_resolution _ < "$dev"
[[ $single_resolution ]] && resolution="${single_resolution}, ${resolution}"
done
fi
resolution="${resolution%%,}"
resolution="${resolution%%, }"
[[ -z "${resolution/x}" ]] && resolution=
}
get_style() {
unset gtk2_theme gtk3_theme theme path
if [[ "$DISPLAY" && $os != "Mac OS X" && $os != "macOS" ]]; then
((de_run != 1)) && get_de
[[ $de_version == on ]] && de=${de/ *}
case $de in
"KDE"* | "Plasma"*)
kde_config_dir
if [[ -f "${kde_config_dir}/kdeglobals" ]]; then
kde_config_file="${kde_config_dir}/kdeglobals"
kde_theme="$(grep "^${kde}" "$kde_config_file")"
kde_theme="${kde_theme/*=}"
if [[ "$kde" == "font" ]]; then
kde_font_size="${kde_theme#*,}"
kde_font_size="${kde_font_size/,*}"
kde_theme="${kde_theme/,*} ${kde_theme/*,} ${kde_font_size}"
fi
kde_theme="$kde_theme [$de], "
else
err "Theme: KDE config files not found, skipping."
fi
;;
*"Cinnamon"*)
if type -p gsettings >/dev/null; then
gtk3_theme="$(gsettings get org.cinnamon.desktop.interface "$gsettings")"
gtk2_theme="$gtk3_theme"
fi
;;
"Gnome"* | "Unity"* | "Budgie"*)
if type -p gsettings >/dev/null; then
gtk3_theme="$(gsettings get org.gnome.desktop.interface "$gsettings")"
gtk2_theme="$gtk3_theme"
elif type -p gconftool-2 >/dev/null; then
gtk2_theme="$(gconftool-2 -g /desktop/gnome/interface/"$gconf")"
fi
;;
"Mate"*)
gtk3_theme="$(gsettings get org.mate.interface "$gsettings")"
gtk2_theme="$gtk3_theme"
;;
"Xfce"*)
type -p xfconf-query >/dev/null && \
gtk2_theme="$(xfconf-query -c xsettings -p "$xfconf")"
;;
esac
if [[ -z "$gtk2_theme" ]]; then
if [[ -n "$GTK2_RC_FILES" ]]; then
IFS=: read -ra rc_files <<< "$GTK2_RC_FILES"
gtk2_theme="$(grep "^[^#]*${name}" "${rc_files[@]}")"
elif [[ -f "${HOME}/.gtkrc-2.0"  ]]; then
gtk2_theme="$(grep "^[^#]*${name}" "${HOME}/.gtkrc-2.0")"
elif [[ -f "/etc/gtk-2.0/gtkrc" ]]; then
gtk2_theme="$(grep "^[^#]*${name}" /etc/gtk-2.0/gtkrc)"
elif [[ -f "/usr/share/gtk-2.0/gtkrc" ]]; then
gtk2_theme="$(grep "^[^#]*${name}" /usr/share/gtk-2.0/gtkrc)"
fi
gtk2_theme="${gtk2_theme/*${name}*=}"
fi
if [[ -z "$gtk3_theme" ]]; then
if [[ -f "${XDG_CONFIG_HOME}/gtk-3.0/settings.ini" ]]; then
gtk3_theme="$(grep "^[^#]*$name" "${XDG_CONFIG_HOME}/gtk-3.0/settings.ini")"
elif type -p gsettings >/dev/null; then
gtk3_theme="$(gsettings get org.gnome.desktop.interface "$gsettings")"
elif [[ -f "/etc/gtk-3.0/settings.ini" ]]; then
gtk3_theme="$(grep "^[^#]*$name" /etc/gtk-3.0/settings.ini)"
elif [[ -f "/usr/share/gtk-3.0/settings.ini" ]]; then
gtk3_theme="$(grep "^[^#]*$name" /usr/share/gtk-3.0/settings.ini)"
fi
gtk3_theme="${gtk3_theme/${name}*=}"
fi
gtk2_theme="$(trim "$gtk2_theme")"
gtk3_theme="$(trim "$gtk3_theme")"
gtk2_theme="$(trim_quotes "$gtk2_theme")"
gtk3_theme="$(trim_quotes "$gtk3_theme")"
[[ "$gtk2" == "off" ]] && unset gtk2_theme
[[ "$gtk3" == "off" ]] && unset gtk3_theme
if [[ "$gtk2_theme" && "$gtk2_theme" == "$gtk3_theme" ]]; then
gtk3_theme+=" [GTK2/3]"
unset gtk2_theme
elif [[ "$gtk2_theme" && "$gtk3_theme" ]]; then
gtk2_theme+=" [GTK2], "
gtk3_theme+=" [GTK3] "
else
[[ "$gtk2_theme" ]] && gtk2_theme+=" [GTK2] "
[[ "$gtk3_theme" ]] && gtk3_theme+=" [GTK3] "
fi
theme="${kde_theme}${gtk2_theme}${gtk3_theme}"
theme="${theme%, }"
if [[ "$gtk_shorthand" == "on" ]]; then
theme="${theme// '[GTK'[0-9]']'}"
theme="${theme/ '[GTK2/3]'}"
theme="${theme/ '[KDE]'}"
theme="${theme/ '[Plasma]'}"
fi
fi
}
get_theme() {
name="gtk-theme-name"
gsettings="gtk-theme"
gconf="gtk_theme"
xfconf="/Net/ThemeName"
kde="Name"
get_style
}
get_icons() {
name="gtk-icon-theme-name"
gsettings="icon-theme"
gconf="icon_theme"
xfconf="/Net/IconThemeName"
kde="Theme"
get_style
icons="$theme"
}
get_font() {
name="gtk-font-name"
gsettings="font-name"
gconf="font_theme"
xfconf="/Gtk/FontName"
kde="font"
get_style
font="$theme"
}
get_term() {
((term_run == 1)) && return
case $TERM_PROGRAM in
"iTerm.app")term="iTerm2" ;;
"Terminal.app") term="Apple Terminal" ;;
"Hyper")term="HyperTerm" ;;
*)  term="${TERM_PROGRAM/\.app}" ;;
esac
[[ "$TERM" == "tw52" || "$TERM" == "tw100" ]] && term="TosWin2"
[[ "$SSH_CONNECTION" ]] && term="$SSH_TTY"
[[ "$WT_SESSION" ]] && term="Windows Terminal"
while [[ -z "$term" ]]; do
parent="$(get_ppid "$parent")"
[[ -z "$parent" ]] && break
name="$(get_process_name "$parent")"
case ${name// } in
"${SHELL/*\/}"|*"sh"|"screen"|"su"*|"newgrp") ;;
"login"*|*"Login"*|"init"|"(init)")
term="$(tty)"
;;
"ruby"|"1"|"tmux"*|"systemd"|"sshd"*|"python"*|\
"USER"*"PID"*|"kdeinit"*|"launchd"*|"bwrap")
break
;;
"gnome-terminal-") term="gnome-terminal" ;;
"urxvtd")  term="urxvt" ;;
*"nvim")   term="Neovim Terminal" ;;
*"NeoVimServer"*)  term="VimR Terminal" ;;
*)
[[ $os == Linux ]] && term=$(realpath "/proc/$parent/exe")
term="${name##*/}"
[[ $term == .*-wrapped ]] && {
 term="${term#.}"
 term="${term%-wrapped}"
}
;;
esac
done
term_run=1
}
get_term_font() {
((term_run != 1)) && get_term
case $term in
"alacritty"*)
shopt -s nullglob
confs=({$XDG_CONFIG_HOME,$HOME}/{alacritty,}/{.,}alacritty.ym?)
shopt -u nullglob
[[ -f "${confs[0]}" ]] || return
term_font="$(awk '/normal:/ {while (!/family:/ || /#/)
 {if (!getline) {exit}} print; exit}' "${confs[0]}")"
term_font="${term_font/*family:}"
term_font="${term_font/$'\n'*}"
term_font="${term_font/\#*}"
term_font="${term_font//\"}"
;;
"Apple_Terminal")
term_font="$(osascript <<END
 tell application "Terminal" to font name of window frontmost
END
)"
;;
"iTerm2")
local current_profile_name profiles_count profile_name diff_font
current_profile_name="$(osascript <<END
tell application "iTerm2" to profile name \
of current session of current window
END
)"
font_file="${HOME}/Library/Preferences/com.googlecode.iterm2.plist"
profiles_count="$(PlistBuddy -c "Print ':New Bookmarks:'" "$font_file" | \
grep -w -c "Guid")"
for ((i=0; i<profiles_count; i++)); do
profile_name="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Name:'" "$font_file")"
if [[ "$profile_name" == "$current_profile_name" ]]; then
term_font="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Normal Font:'" \
 "$font_file")"
diff_font="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Use Non-ASCII Font:'" \
 "$font_file")"
if [[ "$diff_font" == "true" ]]; then
non_ascii="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Non Ascii Font:'" \
 "$font_file")"
[[ "$term_font" != "$non_ascii" ]] && \
term_font="$term_font (normal) / $non_ascii (non-ascii)"
fi
fi
done
;;
"deepin-terminal"*)
term_font="$(awk -F '=' '/font=/ {a=$2} /font_size/ {b=$2} END {print a,b}' \
 "${XDG_CONFIG_HOME}/deepin/deepin-terminal/config.conf")"
;;
"GNUstep_Terminal")
 term_font="$(awk -F '>|<' '/>TerminalFont</ {getline; f=$3}
/>TerminalFontSize</ {getline; s=$3} END {print f,s}' \
"${HOME}/GNUstep/Defaults/Terminal.plist")"
;;
"Hyper"*)
term_font="$(awk -F':|,' '/fontFamily/ {print $2; exit}' "${HOME}/.hyper.js")"
term_font="$(trim_quotes "$term_font")"
;;
"kitty"*)
term_font="from kitty.cli import *; o = create_default_opts(); \
 print(f'{o.font_family} {o.font_size}')"
term_font="$(kitty +runpy ''"$term_font"'')"
;;
"konsole" | "yakuake")
child="$(get_ppid "$$")"
QT_BINDIR="$(qtpaths --binaries-dir)" && PATH+=":$QT_BINDIR"
IFS=$'\n' read -d "" -ra konsole_instances \
<<< "$(qdbus | awk '/org.kde.'"$term"'/ {print $1}')"
for i in "${konsole_instances[@]}"; do
IFS=$'\n' read -d "" -ra konsole_sessions <<< "$(qdbus "$i" | grep -F '/Sessions/')"
for session in "${konsole_sessions[@]}"; do
if ((child == "$(qdbus "$i" "$session" processId)")); then
profile="$(qdbus "$i" "$session" environment |\
 awk -F '=' '/KONSOLE_PROFILE_NAME/ {print $2}')"
[[ $profile ]] || profile="$(qdbus "$i" "$session" profile)"
break
fi
done
[[ $profile ]] && break
done
[[ $profile ]] || return
profile_filename="$(grep -l "Name=${profile}" "$HOME"/.local/share/konsole/*.profile)"
profile_filename="${profile_filename/$'\n'*}"
[[ $profile_filename ]] && \
term_font="$(awk -F '=|,' '/Font=/ {print $2,$3}' "$profile_filename")"
;;
"lxterminal"*)
term_font="$(awk -F '=' '/fontname=/ {print $2; exit}' \
 "${XDG_CONFIG_HOME}/lxterminal/lxterminal.conf")"
;;
"mate-terminal")
mateterm_config="/tmp/mateterm.cfg"
if [[ -d "/tmp" && ! -f "$mateterm_config" ]]; then
mate-terminal --save-config="$mateterm_config"
role="$(xprop -id "${WINDOWID}" WM_WINDOW_ROLE)"
role="${role##* }"
role="${role//\"}"
profile="$(awk -F '=' -v r="$role" \
'$0~r {
getline;
if(/Maximized/) getline;
if(/Fullscreen/) getline;
id=$2"]"
 } $0~id {if(id) {getline; print $2; exit}}' \
 "$mateterm_config")"
rm -f "$mateterm_config"
mate_get() {
 gsettings get org.mate.terminal.profile:/org/mate/terminal/profiles/"$1"/ "$2"
}
if [[ "$(mate_get "$profile" "use-system-font")" == "true" ]]; then
term_font="$(gsettings get org.mate.interface monospace-font-name)"
else
term_font="$(mate_get "$profile" "font")"
fi
term_font="$(trim_quotes "$term_font")"
fi
;;
"mintty")
term_font="$(awk -F '=' '!/^($|#)/ && /^\\s*Font\\s*=/ {printf $2; exit}' "${HOME}/.minttyrc")"
;;
"pantheon"*)
term_font="$(gsettings get org.pantheon.terminal.settings font)"
[[ -z "${term_font//\'}" ]] && \
term_font="$(gsettings get org.gnome.desktop.interface monospace-font-name)"
term_font="$(trim_quotes "$term_font")"
;;
"qterminal")
term_font="$(awk -F '=' '/fontFamily=/ {a=$2} /fontSize=/ {b=$2} END {print a,b}' \
 "${XDG_CONFIG_HOME}/qterminal.org/qterminal.ini")"
;;
"sakura"*)
term_font="$(awk -F '=' '/^font=/ {print $2; exit}' \
 "${XDG_CONFIG_HOME}/sakura/sakura.conf")"
;;
"st")
term_font="$(ps -o command= -p "$parent" | grep -F -- "-f")"
if [[ "$term_font" ]]; then
term_font="${term_font/*-f/}"
term_font="${term_font/ -*/}"
else
[[ -L "/proc/$parent/exe" ]] && binary="/proc/$parent/exe" || binary="$(type -p st)"
[[ -n "$binary" ]] &&
term_font=$(
strings "$binary" |
grep -m 1 "*font[^2]"
)
fi
term_font="${term_font/xft:}"
term_font="${term_font#*=}"
term_font="${term_font/:*}"
;;
"terminology")
term_font="$(strings "${XDG_CONFIG_HOME}/terminology/config/standard/base.cfg" |\
 awk '/^font\.name$/{print a}{a=$0}')"
term_font="${term_font/.pcf}"
term_font="${term_font/:*}"
;;
"termite")
[[ -f "${XDG_CONFIG_HOME}/termite/config" ]] && \
termite_config="${XDG_CONFIG_HOME}/termite/config"
term_font="$(awk -F '= ' '/\[options\]/ {
opt=1
}
/^\s*font/ {
if(opt==1) a=$2;
opt=0
} END {print a}' "/etc/xdg/termite/config" \
 "$termite_config")"
;;
urxvt|urxvtd|rxvt-unicode|xterm)
xrdb=$(xrdb -query)
term_font=$(grep -im 1 -e "^${term/d}"'\**\.*font:' -e '^\*font:' <<< "$xrdb")
term_font=${term_font/*"*font:"}
term_font=${term_font/*".font:"}
term_font=${term_font/*"*.font:"}
term_font=$(trim "$term_font")
[[ -z $term_font && $term == xterm ]] && \
term_font=$(grep '^XTerm.vt100.faceName' <<< "$xrdb")
term_font=$(trim "${term_font/*"faceName:"}")
[[ ${term_font:0:1} != '-' && ${term_font:0:4} != xft: ]] && \
term_font=xft:$term_font
case $term_font in
*xft:*)
term_font=${term_font/xft:}
term_font=${term_font/:*}
;;
-*)
IFS=- read -r _ _ term_font _ <<< "$term_font"
;;
esac
;;
"xfce4-terminal")
term_font="$(awk -F '=' '/^FontName/{a=$2}/^FontUseSystem=TRUE/{a=$0} END {print a}' \
 "${XDG_CONFIG_HOME}/xfce4/terminal/terminalrc")"
[[ "$term_font" == "FontUseSystem=TRUE" ]] && \
term_font="$(gsettings get org.gnome.desktop.interface monospace-font-name)"
term_font="$(trim_quotes "$term_font")"
[[ -z "$term_font" ]] && term_font="Monospace 12"
;;
conemu-*)
`eval set -- "$ConEmuArgs"` instead for arg parsing.
readarray -t ce_arg_list < <(xargs -n1 printf "%s\n" <<< "${ConEmuArgs-}")
for ce_arg_idx in "${!ce_arg_list[@]}"; do
[[ "${ce_arg_list[$ce_arg_idx]}" == -LoadCfgFile ]] && {
ce_conf=${ce_arg_list[++ce_arg_idx]}
break
}
done
for ce_conf in "$ce_conf" "${ConEmuDir-}\ConEmu.xml" "${ConEmuDir-}\.ConEmu.xml" \
 "${ConEmuBaseDir-}\ConEmu.xml" "${ConEmuBaseDir-}\.ConEmu.xml" \
 "$APPDATA\ConEmu.xml" "$APPDATA\.ConEmu.xml"; do
[[ -f "$ce_conf" ]] && {
term_font="$(awk '/name="FontName"/ && match($0, /data="([^"]*)"/) {
print substr($0, RSTART+6, RLENGTH-7)}' "$ce_conf")"
break
}
done
[[ "$term_font" ]] || read -r term_font < \
/proc/registry/HKEY_CURRENT_USER/Software/ConEmu/.Vanilla/FontName
;;
esac
}
get_disk() {
type -p df &>/dev/null ||
{ err "Disk requires 'df' to function. Install 'df' to get disk info."; return; }
df_version=$(df --version 2>&1)
case $df_version in
*IMitv*)   df_flags=(-P -g) ;; # AIX
*befhikm*) df_flags=(-P -k) ;; # IRIX
*hiklnP*)  df_flags=(-h);; # OpenBSD
*Tracker*) # Haiku
err "Your version of df cannot be used due to the non-standard flags"
return
;;
*) df_flags=(-P -h) ;;
esac
IFS=$'\n' read -d "" -ra disks <<< "$(df "${df_flags[@]}" "${disk_show[@]:-/}")"
unset "disks[0]"
[[ ${disks[*]} ]] || {
err "Disk: df failed to print the disks, make sure the disk_show array is set properly."
return
}
for disk in "${disks[@]}"; do
IFS=" " read -ra disk_info <<< "$disk"
disk_perc=${disk_info[${#disk_info[@]} - 2]/\%}
case $disk_percent in
off) disk_perc=
esac
case $df_version in
*befhikm*)
disk=$((disk_info[${#disk_info[@]} - 4] / 1024 / 1024))G
disk+=" / "
disk+=$((disk_info[${#disk_info[@]} - 5] / 1024/ 1024))G
disk+=${disk_perc:+ ($disk_perc%)}
;;
*)
disk=${disk_info[${#disk_info[@]} - 4]/i}
disk+=" / "
disk+=${disk_info[${#disk_info[@]} - 5]/i}
disk+=${disk_perc:+ ($disk_perc%)}
;;
esac
case $disk_subtitle in
name)
disk_sub=${disk_info[*]::${#disk_info[@]} - 5}
;;
dir)
disk_sub=${disk_info[${#disk_info[@]} - 1]/*\/}
disk_sub=${disk_sub:-${disk_info[${#disk_info[@]} - 1]}}
;;
none) ;;
*)
disk_sub=${disk_info[${#disk_info[@]} - 1]}
;;
esac
case $disk_display in
bar) disk="$(bar "$disk_perc" "100")" ;;
infobar) disk+=" $(bar "$disk_perc" "100")" ;;
barinfo) disk="$(bar "$disk_perc" "100")${info_color} $disk" ;;
perc)disk="${disk_perc}% $(bar "$disk_perc" "100")" ;;
esac
if [[ "$subtitle" ]]; then
prin "$subtitle${disk_sub:+ ($disk_sub)}" "$disk"
else
prin "$disk_sub" "$disk"
fi
done
}
get_battery() {
for bat in "/sys/class/power_supply/"{BAT,axp288_fuel_gauge,CMB}*; do
capacity="$(< "${bat}/capacity")"
status="$(< "${bat}/status")"
if [[ "$capacity" ]]; then
battery="${capacity}% [${status}]"
case $battery_display in
"bar") battery="$(bar "$capacity" 100)" ;;
"infobar") battery+=" $(bar "$capacity" 100)" ;;
"barinfo") battery="$(bar "$capacity" 100)${info_color} ${battery}" ;;
esac
bat="${bat/*axp288_fuel_gauge}"
prin "${subtitle:+${subtitle}${bat: -1}}" "$battery"
fi
done
[[ "$battery_state" ]] && battery+=" Charging"
case $battery_display in
"bar") battery="$(bar "${battery/\%*}" 100)" ;;
"infobar") battery="${battery} $(bar "${battery/\%*}" 100)" ;;
"barinfo") battery="$(bar "${battery/\%*}" 100)${info_color} ${battery}" ;;
esac
}
get_local_ip() {
if [[ "${local_ip_interface[0]}" == "auto" ]]; then
local_ip="$(ip route get 1 | awk -F'src' '{print $2; exit}')"
local_ip="${local_ip/uid*}"
[[ "$local_ip" ]] || local_ip="$(ifconfig -a | awk '/broadcast/ {print $2; exit}')"
else
for interface in "${local_ip_interface[@]}"; do
local_ip="$(ip addr show "$interface" 2> /dev/null |
awk '/inet / {print $2; exit}')"
local_ip="${local_ip/\/*}"
[[ "$local_ip" ]] ||
local_ip="$(ifconfig "$interface" 2> /dev/null |
awk '/broadcast/ {print $2; exit}')"
if [[ -n "$local_ip" ]]; then
prin "$interface" "$local_ip"
else
err "Local IP: Could not detect local ip for $interface"
fi
done
fi
}
get_public_ip() {
if [[ ! -n "$public_ip_host" ]] && type -p dig >/dev/null; then
public_ip="$(dig +time=1 +tries=1 +short myip.opendns.com @resolver1.opendns.com)"
 [[ "$public_ip" =~ ^\; ]] && unset public_ip
fi
if [[ ! -n "$public_ip_host" ]] && [[ -z "$public_ip" ]] && type -p drill >/dev/null; then
public_ip="$(drill myip.opendns.com @resolver1.opendns.com | \
 awk '/^myip\./ && $3 == "IN" {print $5}')"
fi
if [[ -z "$public_ip" ]] && type -p curl >/dev/null; then
public_ip="$(curl -L --max-time "$public_ip_timeout" -w '\n' "$public_ip_host")"
fi
if [[ -z "$public_ip" ]] && type -p wget >/dev/null; then
public_ip="$(wget -T "$public_ip_timeout" -qO- "$public_ip_host")"
fi
}
get_users() {
users="$(who | awk '!seen[$1]++ {printf $1 ", "}')"
users="${users%\,*}"
}
get_locale() {
locale="$sys_locale"
}
get_gpu_driver() {
gpu_driver="$(lspci -nnk | awk -F ': ' \
'/Display|3D|VGA/{nr[NR+2]}; NR in nr {printf $2 ", "; exit}')"
gpu_driver="${gpu_driver%, }"
if [[ "$gpu_driver" == *"nvidia"* ]]; then
gpu_driver="$(< /proc/driver/nvidia/version)"
gpu_driver="${gpu_driver/*Module  }"
gpu_driver="NVIDIA ${gpu_driver/  *}"
fi
}
get_cols() {
local blocks blocks2 cols
if [[ "$color_blocks" == "on" ]]; then
printf -v block_width "%${block_width}s"
for ((block_range[0]; block_range[0]<=block_range[1]; block_range[0]++)); do
case ${block_range[0]} in
[0-7])
printf -v blocks  '%b\e[3%bm\e[4%bm%b' \
"$blocks" "${block_range[0]}" "${block_range[0]}" "$block_width"
;;
*)
printf -v blocks2 '%b\e[38;5;%bm\e[48;5;%bm%b' \
"$blocks2" "${block_range[0]}" "${block_range[0]}" "$block_width"
;;
esac
done
printf -v block_spaces "%${block_height}s"
[[ "$blocks"  ]] && cols+="${block_spaces// /${blocks}[mnl}"
[[ "$blocks2" ]] && cols+="${block_spaces// /${blocks2}[mnl}"
cols=${cols%%nl}
cols=${cols//nl/
[${text_padding}C${zws}}
((info_height+=block_range[1]>7?block_height+2:block_height+1))
case $col_offset in
"auto") printf '\n\e[%bC%b\n' "$text_padding" "${zws}${cols}" ;;
*) printf '\n\e[%bC%b\n' "$col_offset" "${zws}${cols}" ;;
esac
fi
unset -v blocks blocks2 cols
prin=1
}
image_backend() {
[[ "$image_backend" != "off" ]] && ! type -p convert &>/dev/null && \
{ image_backend="ascii"; err "Image: Imagemagick not found, falling back to ascii mode."; }
case ${image_backend:-off} in
"ascii") print_ascii ;;
"off") image_backend="off" ;;
"caca" | "catimg" | "chafa" | "jp2a" | "iterm2" | "termpix" |\
"tycat" | "w3m" | "sixel" | "pixterm" | "kitty" | "pot", | "ueberzug" |\
 "viu")
get_image_source
[[ ! -f "$image" ]] && {
to_ascii "Image: '$image_source' doesn't exist, falling back to ascii mode."
return
}
[[ "$image_backend" == "ueberzug" ]] && wait=true;
get_window_size
((term_width < 1)) && {
to_ascii "Image: Failed to find terminal window size."
err "Image: Check the 'Images in the terminal' wiki page for more info,"
return
}
printf '\e[2J\e[H'
get_image_size
make_thumbnail
display_image || to_off "Image: $image_backend failed to display the image."
;;
*)
err "Image: Unknown image backend specified '$image_backend'."
err "Image: Valid backends are: 'ascii', 'caca', 'catimg', 'chafa', 'jp2a', 'iterm2',
'kitty', 'off', 'sixel', 'pot', 'pixterm', 'termpix',
'tycat', 'w3m', 'viu')"
err "Image: Falling back to ascii mode."
print_ascii
;;
esac
[[ "$image_backend" != "off" ]] && printf '\e[%sA\e[9999999D' "${lines:-0}"
}
print_ascii() {
if [[ -f "$image_source" && ! "$image_source" =~ (png|jpg|jpeg|jpe|svg|gif) ]]; then
ascii_data="$(< "$image_source")"
elif [[ "$image_source" == "ascii" || $image_source == auto ]]; then
:
else
ascii_data="$image_source"
fi
LC_ALL="$sys_locale"
while IFS=$'\n' read -r line; do
line=${line//\\\\/\\}
line=${line//█/ }
((++lines,${#line}>ascii_len)) && ascii_len="${#line}"
done <<< "${ascii_data//\$\{??\}}"
((lines==1)) && {
lines=
ascii_len=
image_source=auto
get_distro_ascii
print_ascii
return
}
ascii_data="${ascii_data//\$\{c1\}/$c1}"
ascii_data="${ascii_data//\$\{c2\}/$c2}"
ascii_data="${ascii_data//\$\{c3\}/$c3}"
ascii_data="${ascii_data//\$\{c4\}/$c4}"
ascii_data="${ascii_data//\$\{c5\}/$c5}"
ascii_data="${ascii_data//\$\{c6\}/$c6}"
((text_padding=ascii_len+gap))
printf '%b\n' "$ascii_data${reset}"
LC_ALL=C
}
get_image_source() {
case $image_source in
"auto" | "wall" | "wallpaper")
get_wallpaper
;;
*)
image_source="$(get_full_path "$image_source")"
if [[ -d "$image_source" ]]; then
shopt -s nullglob
files=("${image_source%/}"/*.{png,jpg,jpeg,jpe,gif,svg})
shopt -u nullglob
image="${files[RANDOM % ${#files[@]}]}"
else
image="$image_source"
fi
;;
esac
err "Image: Using image '$image'"
}
get_wallpaper() {
((de_run != 1)) && get_de
type -p wal >/dev/null && [[ -f "${HOME}/.cache/wal/wal" ]] && \
{ image="$(< "${HOME}/.cache/wal/wal")"; return; }
case $de in
"MATE"*)
image="$(gsettings get org.mate.background picture-filename)"
;;
"Xfce"*)
image="$(xfconf-query -c xfce4-desktop -p \
"/backdrop/screen0/monitor0/workspace0/last-image")"
;;
"Cinnamon"*)
image="$(gsettings get org.cinnamon.desktop.background picture-uri)"
image="$(decode_url "$image")"
;;
"GNOME"*)
image="$(gsettings get org.gnome.desktop.background picture-uri)"
image="$(decode_url "$image")"
;;
"Plasma"*)
image=$XDG_CONFIG_HOME/plasma-org.kde.plasma.desktop-appletsrc
image=$(awk -F '=' '$1 == "Image" { print $2 }' "$image")
;;
"LXQt"*)
image="$XDG_CONFIG_HOME/pcmanfm-qt/lxqt/settings.conf"
image="$(awk -F '=' '$1 == "Wallpaper" {print $2}' "$image")"
;;
*)
if type -p feh >/dev/null && [[ -f "${HOME}/.fehbg" ]]; then
image="$(awk -F\' '/feh/ {printf $(NF-1)}' "${HOME}/.fehbg")"
elif type -p setroot >/dev/null && \
[[ -f "${XDG_CONFIG_HOME}/setroot/.setroot-restore" ]]; then
image="$(awk -F\' '/setroot/ {printf $(NF-1)}' \
"${XDG_CONFIG_HOME}/setroot/.setroot-restore")"
elif type -p nitrogen >/dev/null; then
image="$(awk -F'=' '/file/ {printf $2;exit;}' \
"${XDG_CONFIG_HOME}/nitrogen/bg-saved.cfg")"
else
image="$(gsettings get org.gnome.desktop.background picture-uri)"
image="$(decode_url "$image")"
fi
;;
esac
image="${image/file:\/\/}"
image="$(trim_quotes "$image")"
[[ "${image/*\./}" == "xml" ]] && image=""
}
get_w3m_img_path() {
shopt -s nullglob
w3m_paths=({/usr/{local/,},~/.nix-profile/}{lib,libexec,lib64,libexec64}/w3m/w3mi*)
shopt -u nullglob
[[ -x "${w3m_paths[0]}" ]] && \
{ w3m_img_path="${w3m_paths[0]}"; return; }
err "Image: w3m-img wasn't found on your system"
}
get_window_size() {
#
if [[ "$image_backend" == "tycat" ]]; then
printf '%b' '\e}qs\000'
elif [[ -z $VTE_VERSION ]]; then
case ${TMUX:-null} in
"null") printf '%b' '\e[14t' ;;
*)  printf '%b' '\ePtmux;\e\e[14t\e\\ ' ;;
esac
fi
#
case $bash_version in
4|5) IFS=';t' read -d t -t 0.05 -sra term_size ;;
*)   IFS=';t' read -d t -t 1 -sra term_size ;;
esac
unset IFS
if [[ "$image_backend" == "tycat" ]]; then
term_width="$((term_size[2] * term_size[0]))"
term_height="$((term_size[3] * term_size[1]))"
else
term_height="${term_size[1]}"
term_width="${term_size[2]}"
fi
if (( "${term_width:-0}" < 50 )) && [[ "$DISPLAY" && $os != "Mac OS X" && $os != "macOS" ]]; then
if type -p xdotool &>/dev/null; then
IFS=$'\n' read -d "" -ra win \
<<< "$(xdotool getactivewindow getwindowgeometry --shell %1)"
term_width="${win[3]/WIDTH=}"
term_height="${win[4]/HEIGHT=}"
elif type -p xwininfo &>/dev/null; then
if type -p xdo &>/dev/null; then
current_window="$(xdo id)"
elif type -p xprop &>/dev/null; then
current_window="$(xprop -root _NET_ACTIVE_WINDOW)"
current_window="${current_window##* }"
elif type -p xdpyinfo &>/dev/null; then
current_window="$(xdpyinfo | grep -F "focus:")"
current_window="${current_window/*window }"
current_window="${current_window/,*}"
fi
if [[ "$current_window" ]]; then
term_size=("$(xwininfo -id "$current_window")")
term_width="${term_size[0]#*Width: }"
term_width="${term_width/$'\n'*}"
term_height="${term_size[0]/*Height: }"
term_height="${term_height/$'\n'*}"
fi
fi
fi
term_width="${term_width:-0}"
}
get_term_size() {
read -r lines columns <<< "$(stty size)"
font_width="$((term_width / columns))"
font_height="$((term_height / lines))"
}
get_image_size() {
get_term_size
case $image_size in
"auto")
image_size="$((columns * font_width / 2))"
term_height="$((term_height - term_height / 4))"
((term_height < image_size)) && \
image_size="$term_height"
;;
*"%")
percent="${image_size/\%}"
image_size="$((percent * term_width / 100))"
(((percent * term_height / 50) < image_size)) && \
image_size="$((percent * term_height / 100))"
;;
"none")
read -r width height <<< "$(identify -format "%w %h" "$image")"
while ((width >= (term_width / 2) || height >= term_height)); do
((width=width/2,height=height/2))
done
crop_mode="none"
;;
*)  image_size="${image_size/px}" ;;
esac
[[ "$image_backend" == "w3m" ]] && term_padding
width="${width:-$image_size}"
height="${height:-$image_size}"
text_padding="$(((width + padding + xoffset) / font_width + gap))"
}
make_thumbnail() {
image_name="${crop_mode}-${crop_offset}-${width}-${height}-${image//\/}"
case ${image##*.} in
"eps"|"pdf"|"svg"|"gif"|"png")
image_name+=".png" ;;
*)  image_name+=".jpg" ;;
esac
mkdir -p "${thumbnail_dir:=${XDG_CACHE_HOME:-${HOME}/.cache}/thumbnails/neofetch}"
if [[ ! -f "${thumbnail_dir}/${image_name}" ]]; then
[[ -z "$size" ]] && {
read -r og_width og_height <<< "$(identify -format "%w %h" "$image")"
((og_height > og_width)) && size="$og_width" || size="$og_height"
}
case $crop_mode in
"fit")
c="$(convert "$image" \
-colorspace srgb \
-format "%[pixel:p{0,0}]" info:)"
convert \
-background none \
"$image" \
-trim +repage \
-gravity south \
-background "$c" \
-extent "${size}x${size}" \
-scale "${width}x${height}" \
"${thumbnail_dir}/${image_name}"
;;
"fill")
convert \
-background none \
"$image" \
-trim +repage \
-scale "${width}x${height}^" \
-extent "${width}x${height}" \
"${thumbnail_dir}/${image_name}"
;;
"none")
cp "$image" "${thumbnail_dir}/${image_name}"
;;
*)
convert \
-background none \
"$image" \
-strip \
-gravity "$crop_offset" \
-crop "${size}x${size}+0+0" \
-scale "${width}x${height}" \
"${thumbnail_dir}/${image_name}"
;;
esac
fi
image="${thumbnail_dir}/${image_name}"
}
display_image() {
case $image_backend in
"caca")
img2txt \
-W "$((width / font_width))" \
-H "$((height / font_height))" \
--gamma=0.6 \
"$image"
;;
"ueberzug")
if [ "$wait" = true ];then
wait=false;
else
ueberzug layer --parser bash 0< <(
declare -Ap ADD=(\
[action]="add"\
[identifier]="neofetch"\
[x]=$xoffset [y]=$yoffset\
[path]=$image\
)
read -rs
)
fi
;;
"catimg")
catimg -w "$((width*catimg_size / font_width))" -r "$catimg_size" "$image"
;;
"chafa")
chafa --stretch --size="$((width / font_width))x$((height / font_height))" "$image"
;;
"jp2a")
jp2a \
--colors \
--width="$((width / font_width))" \
--height="$((height / font_height))" \
"$image"
;;
"kitty")
kitty +kitten icat \
--align left \
--place "$((width/font_width))x$((height/font_height))@${xoffset}x${yoffset}" \
"$image"
;;
"pot")
pot \
"$image" \
--size="$((width / font_width))x$((height / font_height))"
;;
"pixterm")
pixterm \
-tc "$((width / font_width))" \
-tr "$((height / font_height))" \
"$image"
;;
"sixel")
img2sixel \
-w "$width" \
-h "$height" \
"$image"
;;
"termpix")
termpix \
--width "$((width / font_width))" \
--height "$((height / font_height))" \
"$image"
;;
"iterm2")
printf -v iterm_cmd '\e]1337;File=width=%spx;height=%spx;inline=1:%s' \
"$width" "$height" "$(base64 < "$image")"
[[ -n "$TMUX" ]] && printf -v iterm_cmd '\ePtmux;\e%b\e'\\ "$iterm_cmd"
printf '%b\a\n' "$iterm_cmd"
;;
"tycat")
tycat \
-g "${width}x${height}" \
"$image"
;;
"viu")
viu \
-t -w "$((width / font_width))" -h "$((height / font_height))" \
"$image"
;;
"w3m")
get_w3m_img_path
zws='\xE2\x80\x8B\x20'
((bash_version>3)) && sleep 0.05
printf '%b\n%s;\n%s\n' "0;1;$xoffset;$yoffset;$width;$height;;;;;$image" 3 4 | "${w3m_img_path:-false}" -bg "$background_color" &>/dev/null
;;
esac
}
to_ascii() {
err "$1"
image_backend="ascii"
print_ascii
printf '\e[%sA\e[9999999D' "${lines:-0}"
}
to_off() {
err "$1"
image_backend="off"
text_padding=
}
info() {
[[ "$2" ]] && subtitle="$1"
unset -v prin
"get_${2:-$1}"
[[ "$prin" ]] && return
if [[ "$2" ]]; then
output="$(trim "${!2}")"
else
output="$(trim "${!1}")"
fi
if [[ "$2" && "${output// }" ]]; then
prin "$1" "$output"
elif [[ "${output// }" ]]; then
prin "$output"
else
err "Info: Couldn't detect ${1}."
fi
unset -v subtitle
}
prin() {
if [[ "$(trim "$1")" && "$2" ]]; then
[[ "$json" ]] && { printf '%s\n' "\"${1}\": \"${2}\","; return; }
string="${1}${2:+: $2}"
else
string="${2:-$1}"
local subtitle_color="$info_color"
fi
string="$(trim "${string//$'\e[0m'}")"
length="$(strip_sequences "$string")"
length="${#length}"
string="${string/:/${reset}${colon_color}${separator:=:}${info_color}}"
string="${subtitle_color}${bold}${string}"
printf '%b\n' "${text_padding:+\e[${text_padding}C}${zws}${string//\\n}${reset} "
((++info_height))
prin=1
}
get_underline() {
[[ "$underline_enabled" == "on" ]] && {
printf -v underline "%${length}s"
printf '%b%b\n' "${text_padding:+\e[${text_padding}C}${zws}${underline_color}" \
"${underline// /$underline_char}${reset} "
}
((++info_height))
length=
prin=1
}
get_bold() {
case $ascii_bold in
"on")  ascii_bold='\e[1m' ;;
"off") ascii_bold="" ;;
esac
case $bold in
"on")  bold='\e[1m' ;;
"off") bold="" ;;
esac
}
trim() {
set -f
set -- $*
printf '%s\n' "${*//[[:space:]]/}"
set +f
}
trim_quotes() {
trim_output="${1//\'}"
trim_output="${trim_output//\"}"
printf "%s" "$trim_output"
}
strip_sequences() {
strip="${1//$'\e['3[0-9]m}"
strip="${strip//$'\e['[0-9]m}"
strip="${strip//\\e\[[0-9]m}"
strip="${strip//$'\e['38\;5\;[0-9]m}"
strip="${strip//$'\e['38\;5\;[0-9][0-9]m}"
strip="${strip//$'\e['38\;5\;[0-9][0-9][0-9]m}"
printf '%s\n' "$strip"
}
set_colors() {
c1="$(color "$1")${ascii_bold}"
c2="$(color "$2")${ascii_bold}"
c3="$(color "$3")${ascii_bold}"
c4="$(color "$4")${ascii_bold}"
c5="$(color "$5")${ascii_bold}"
c6="$(color "$6")${ascii_bold}"
[[ "$color_text" != "off" ]] && set_text_colors "$@"
}
set_text_colors() {
if [[ "${colors[0]}" == "distro" ]]; then
title_color="$(color "$1")"
at_color="$reset"
underline_color="$reset"
subtitle_color="$(color "$2")"
colon_color="$reset"
info_color="$reset"
((${1:-1} == 8)) && title_color="$reset"
((${2:-7} == 8)) && subtitle_color="$reset"
((${2:-7} == 7)) && subtitle_color="$(color "$1")"
((${1:-1} == 7)) && title_color="$reset"
else
title_color="$(color "${colors[0]}")"
at_color="$(color "${colors[1]}")"
underline_color="$(color "${colors[2]}")"
subtitle_color="$(color "${colors[3]}")"
colon_color="$(color "${colors[4]}")"
info_color="$(color "${colors[5]}")"
fi
if [[ "$bar_color_elapsed" == "distro" ]]; then
bar_color_elapsed="$(color fg)"
else
bar_color_elapsed="$(color "$bar_color_elapsed")"
fi
case ${bar_color_total}${1} in
distro[736]) bar_color_total=$(color "$1") ;;
distro[0-9]) bar_color_total=$(color "$2") ;;
*)   bar_color_total=$(color "$bar_color_total") ;;
esac
}
color() {
case $1 in
[0-6])printf '%b\e[3%sm'   "$reset" "$1" ;;
7 | "fg") printf '\e[37m%b'"$reset" ;;
*)printf '\e[38;5;%bm' "$1" ;;
esac
}
stdout() {
image_backend="off"
unset subtitle_color colon_color info_color underline_color bold title_color at_color \
text_padding zws reset color_blocks bar_color_elapsed bar_color_total \
c1 c2 c3 c4 c5 c6 c7 c8
}
err() {
err+="$(color 1)[!]${reset} $1
"
}
get_full_path() {
[[ -f "${PWD}/${1}" ]] && { printf '%s\n' "${PWD}/${1}"; return; }
! cd "${1%/*}" && {
err "Error: Directory '${1%/*}' doesn't exist or is inaccessible"
err "   Check that the directory exists or try another directory."
exit 1
}
local full_dir="${1##*/}"
while [[ -L "$full_dir" ]]; do
full_dir="$(readlink "$full_dir")"
cd "${full_dir%/*}" || exit
full_dir="${full_dir##*/}"
done
full_dir="$(pwd -P)/${1/*\/}"
[[ -e "$full_dir" ]] && printf '%s\n' "$full_dir"
}
get_user_config() {
if [[ -f "$config_file" ]]; then
source "$config_file"
err "Config: Sourced user config. (${config_file})"
return
elif [[ -f "${XDG_CONFIG_HOME}/neofetch/config.conf" ]]; then
source "${XDG_CONFIG_HOME}/neofetch/config.conf"
err "Config: Sourced user config.(${XDG_CONFIG_HOME}/neofetch/config.conf)"
elif [[ -f "${XDG_CONFIG_HOME}/neofetch/config" ]]; then
source "${XDG_CONFIG_HOME}/neofetch/config"
err "Config: Sourced user config.(${XDG_CONFIG_HOME}/neofetch/config)"
elif [[ -z "$no_config" ]]; then
config_file="${XDG_CONFIG_HOME}/neofetch/config.conf"
mkdir -p "${XDG_CONFIG_HOME}/neofetch/"
printf '%s\n' "$config" > "$config_file"
fi
}
bar() {
elapsed="$(($1 * bar_length / $2))"
printf -v prog  "%${elapsed}s"
printf -v total "%$((bar_length - elapsed))s"
bar+="${bar_color_elapsed}${prog// /${bar_char_elapsed}}"
bar+="${bar_color_total}${total// /${bar_char_total}}"
[[ "$bar_border" == "on" ]] && \
bar="$(color fg)[${bar}$(color fg)]"
printf "%b" "${bar}${info_color}"
}
cache() {
if [[ "$2" ]]; then
mkdir -p "${cache_dir}/neofetch"
printf "%s" "${1/*-}=\"$2\"" > "${cache_dir}/neofetch/${1/*-}"
fi
}
get_cache_dir() {
cache_dir="/tmp"
}
kde_config_dir() {
if [[ "$kde_config_dir" ]]; then
return
elif type -p kf5-config &>/dev/null; then
kde_config_dir="$(kf5-config --path config)"
elif type -p kde4-config &>/dev/null; then
kde_config_dir="$(kde4-config --path config)"
elif type -p kde-config &>/dev/null; then
kde_config_dir="$(kde-config --path config)"
elif [[ -d "${HOME}/.kde4" ]]; then
kde_config_dir="${HOME}/.kde4/share/config"
elif [[ -d "${HOME}/.kde3" ]]; then
kde_config_dir="${HOME}/.kde3/share/config"
fi
kde_config_dir="${kde_config_dir/$'/:'*}"
}
term_padding() {
[[ -z "$term" ]] && get_term
case $term in
urxvt*|rxvt-unicode)
[[ $xrdb ]] || xrdb=$(xrdb -query)
[[ $xrdb != *internalBorder:* ]] &&
return
padding=${xrdb/*internalBorder:}
padding=${padding/$'\n'*}
[[ $padding =~ ^[0-9]+$ ]] ||
padding=
;;
esac
}
dynamic_prompt() {
[[ "$image_backend" == "off" ]]   && { printf '\n'; return; }
[[ "$image_backend" != "ascii" ]] && ((lines=(height + yoffset) / font_height + 1))
[[ "$image_backend" == "w3m" ]]   && ((lines=lines + padding / font_height + 1))
((lines=lines>info_height?lines-info_height+1:1))
printf -v nlines "%${lines}s"
printf "%b" "${nlines// /\\n}"
}
cache_uname() {
IFS=" " read -ra uname <<< "$(uname -srm)"
kernel_name="${uname[0]}"
kernel_version="${uname[1]}"
kernel_machine="${uname[2]}"
if [[ "$kernel_name" == "Darwin" ]]; then
export SYSTEM_VERSION_COMPAT=0
IFS=$'\n' read -d "" -ra sw_vers <<< "$(awk -F'<|>' '/key|string/ {print $3}' \
"/System/Library/CoreServices/SystemVersion.plist")"
for ((i=0;i<${#sw_vers[@]};i+=2)) {
case ${sw_vers[i]} in
ProductName)  darwin_name=${sw_vers[i+1]} ;;
ProductVersion)   osx_version=${sw_vers[i+1]} ;;
ProductBuildVersion)  osx_build=${sw_vers[i+1]}   ;;
esac
}
fi
}
get_ppid() {
case $os in
"Windows")
ppid="$(ps -p "${1:-$PPID}" | awk '{printf $2}')"
ppid="${ppid/PPID}"
;;
"Linux")
ppid="$(grep -i -F "PPid:" "/proc/${1:-$PPID}/status")"
ppid="$(trim "${ppid/PPid:}")"
;;
*)
ppid="$(ps -p "${1:-$PPID}" -o ppid=)"
;;
esac
printf "%s" "$ppid"
}
get_process_name() {
name="$(< "/proc/${1:-$PPID}/comm")"
printf "%s" "$name"
}
decode_url() {
decode="${1//+/ }"
printf "%b" "${decode//%/\\x}"
}
usage() { printf "%s" "\
Usage: neofetch func_name --option \"value\" --option \"value\"
Neofetch is a CLI system information tool written in BASH. Neofetch
displays information about your system next to an image, your OS logo,
or any ASCII file of your choice.
NOTE: Every launch flag has a config option.
Options:
INFO:
func_name   Specify a function name (second part of info() from config) to
quickly display only that function's information.
Example: neofetch uptime --uptime_shorthand tiny
Example: neofetch uptime disk wm memory
This can be used in bars and scripts like so:
memory=\"\$(neofetch memory)\"; memory=\"\${memory##*: }\"
For multiple outputs at once (each line of info in an array):
IFS=\$'\\n' read -d \"\" -ra info < <(neofetch memory uptime wm)
info=(\"\${info[@]##*: }\")
--disable infoname  Allows you to disable an info line from appearing
in the output. 'infoname' is the function name from the
'print_info()' function inside the config file.
For example: 'info \"Memory\" memory' would be '--disable memory'
NOTE: You can supply multiple args. eg. 'neofetch --disable cpu gpu'
--title_fqdn on/off Hide/Show Fully Qualified Domain Name in title.
--package_managers on/off   Hide/Show Package Manager names . (on, tiny, off)
--os_arch on/offHide/Show OS architecture.
--speed_type type   Change the type of cpu speed to display.
Possible values: current, min, max, bios,
scaling_current, scaling_min, scaling_max
NOTE: This only supports Linux with cpufreq.
--speed_shorthand on/offWhether or not to show decimals in CPU speed.
NOTE: This flag is not supported in systems with CPU speed less than
1 GHz.
--cpu_brand on/off  Enable/Disable CPU brand in output.
--cpu_cores typeWhether or not to display the number of CPU cores
Possible values: logical, physical, off
NOTE: 'physical' doesn't work on BSD.
--cpu_speed on/off  Hide/Show cpu speed.
--cpu_temp C/F/off  Hide/Show cpu temperature.
NOTE: This only works on Linux and BSD.
NOTE: For FreeBSD and NetBSD-based systems, you need to enable
coretemp kernel module. This only supports newer Intel processors.
--distro_shorthand on/off   Shorten the output of distro (on, tiny, off)
NOTE: This option won't work in Windows (Cygwin)
--kernel_shorthand on/off   Shorten the output of kernel
NOTE: This option won't work in BSDs (except PacBSD and PC-BSD)
--uptime_shorthand on/off   Shorten the output of uptime (on, tiny, off)
--refresh_rate on/off   Whether to display the refresh rate of each monitor
Unsupported on Windows
--gpu_brand on/off  Enable/Disable GPU brand in output. (AMD/NVIDIA/Intel)
--gpu_type type Which GPU to display. (all, dedicated, integrated)
NOTE: This only supports Linux.
--de_version on/off Show/Hide Desktop Environment version
--gtk_shorthand on/off  Shorten output of gtk theme/icons
--gtk2 on/off   Enable/Disable gtk2 theme/font/icons output
--gtk3 on/off   Enable/Disable gtk3 theme/font/icons output
--shell_path on/off Enable/Disable showing \$SHELL path
--shell_version on/off  Enable/Disable showing \$SHELL version
--disk_show value   Which disks to display.
Possible values: '/', '/dev/sdXX', '/path/to/mount point'
NOTE: Multiple values can be given. (--disk_show '/' '/dev/sdc1')
--disk_subtitle typeWhat information to append to the Disk subtitle.
Takes: name, mount, dir, none
'name' shows the disk's name (sda1, sda2, etc)
'mount' shows the disk's mount point (/, /mnt/Local Disk, etc)
'dir' shows the basename of the disks's path. (/, Local Disk, etc)
'none' shows only 'Disk' or the configured title.
--disk_percent on/off   Hide/Show disk percent.
--ip_host url   URL to query for public IP
--ip_timeout intPublic IP timeout (in seconds).
--ip_interface valueInterface(s) to use for local IP
--song_format formatPrint the song data in a specific format (see config file).
--song_shorthand on/off Print the Artist/Album/Title on separate lines.
--memory_percent on/off Display memory percentage.
--memory_unit kib/mib/gib   Memory output unit.
--music_player player-name  Manually specify a player to use.
Available values are listed in the config file
TEXT FORMATTING:
--colors x x x x x xChanges the text colors in this order:
title, @, underline, subtitle, colon, info
--underline on/off  Enable/Disable the underline.
--underline_char char   Character to use when underlining title
--bold on/off   Enable/Disable bold text
--separator string  Changes the default ':' separator to the specified string.
COLOR BLOCKS:
--color_blocks on/off   Enable/Disable the color blocks
--col_offset auto/num   Left-padding of color blocks
--block_width num   Width of color blocks in spaces
--block_height num  Height of color blocks in lines
--block_range num num   Range of colors to print as blocks
BARS:
--bar_char 'elapsed char' 'total char'
Characters to use when drawing bars.
--bar_border on/off Whether or not to surround the bar with '[]'
--bar_length numLength in spaces to make the bars.
--bar_colors num numColors to make the bar.
Set in this order: elapsed, total
--memory_display mode   Bar mode.
Possible values: bar, infobar, barinfo, off
--battery_display mode  Bar mode.
Possible values: bar, infobar, barinfo, off
--disk_display mode Bar mode.
Possible values: bar, infobar, barinfo, off
IMAGE BACKEND:
--backend backend   Which image backend to use.
Possible values: 'ascii', 'caca', 'catimg', 'chafa', 'jp2a',
'iterm2', 'off', 'sixel', 'tycat', 'w3m', 'kitty', 'viu'
--source source Which image or ascii file to use.
Possible values: 'auto', 'ascii', 'wallpaper', '/path/to/img',
'/path/to/ascii', '/path/to/dir/', 'command output' [ascii]
--ascii source  Shortcut to use 'ascii' backend.
NEW: neofetch --ascii \"\$(fortune | cowsay -W 30)\"
--caca source   Shortcut to use 'caca' backend.
--catimg source Shortcut to use 'catimg' backend.
--chafa source  Shortcut to use 'chafa' backend.
--iterm2 source Shortcut to use 'iterm2' backend.
--jp2a source   Shortcut to use 'jp2a' backend.
--kitty source  Shortcut to use 'kitty' backend.
--pot sourceShortcut to use 'pot' backend.
--pixterm sourceShortcut to use 'pixterm' backend.
--sixel source  Shortcut to use 'sixel' backend.
--termpix sourceShortcut to use 'termpix' backend.
--tycat source  Shortcut to use 'tycat' backend.
--w3m sourceShortcut to use 'w3m' backend.
--ueberzug source   Shortcut to use 'ueberzug' backend
--viu sourceShortcut to use 'viu' backend
--off   Shortcut to use 'off' backend (Disable ascii art).
NOTE: 'source; can be any of the following: 'auto', 'ascii', 'wallpaper', '/path/to/img',
'/path/to/ascii', '/path/to/dir/'
ASCII:
--ascii_colors x x x x x x  Colors to print the ascii art
--ascii_distro version  Which version of distro's ascii art to print ('big' and 'small')
--ascii_bold on/off Whether or not to bold the ascii logo.
-L, --logo  Hide the info text and only show the ascii logo.
IMAGE:
--loop  Redraw the image constantly until Ctrl+C is used. This fixes issues
in some terminals emulators when using image mode.
--size 00px | --size 00%How to size the image.
Possible values: auto, 00px, 00%, none
--catimg_size 1/2   Change the resolution of catimg.
--crop_mode modeWhich crop mode to use
Takes the values: normal, fit, fill
--crop_offset value Change the crop offset for normal mode.
Possible values: northwest, north, northeast,
west, center, east, southwest, south, southeast
--xoffset pxHow close the image will be to the left edge of the
window. This only works with w3m.
--yoffset pxHow close the image will be to the top edge of the
window. This only works with w3m.
--bg_color colorBackground color to display behind transparent image.
This only works with w3m.
--gap num   Gap between image and text.
NOTE: --gap can take a negative value which will move the text
closer to the left side.
--clean Delete cached files and thumbnails.
OTHER:
--config /path/to/configSpecify a path to a custom config file
--config none   Launch the script without a config file
--no_config Don't create the user config file.
--print_config  Print the default config file to stdout.
--stdoutTurn off all colors and disables any ASCII/image backend.
--help  Print this text and exit
--version   Show neofetch version
-v  Display error messages.
-vv Display a verbose log for error reporting.
DEVELOPER:
--gen-man   Generate a manpage for Neofetch in your PWD. (Requires GNU help2man)
Report bugs to https://github.com/dylanaraps/neofetch/issues
"
exit 1
}
get_args() {
[[ "$*" != *--config* && "$*" != *--no_config* ]] && get_user_config
while [[ "$1" ]]; do
case $1 in
"--title_fqdn") title_fqdn="$2" ;;
"--package_managers") package_managers="$2" ;;
"--os_arch") os_arch="$2" ;;
"--cpu_cores") cpu_cores="$2" ;;
"--cpu_speed") cpu_speed="$2" ;;
"--speed_type") speed_type="$2" ;;
"--speed_shorthand") speed_shorthand="$2" ;;
"--distro_shorthand") distro_shorthand="$2" ;;
"--kernel_shorthand") kernel_shorthand="$2" ;;
"--uptime_shorthand") uptime_shorthand="$2" ;;
"--cpu_brand") cpu_brand="$2" ;;
"--gpu_brand") gpu_brand="$2" ;;
"--gpu_type") gpu_type="$2" ;;
"--refresh_rate") refresh_rate="$2" ;;
"--de_version") de_version="$2" ;;
"--gtk_shorthand") gtk_shorthand="$2" ;;
"--gtk2") gtk2="$2" ;;
"--gtk3") gtk3="$2" ;;
"--shell_path") shell_path="$2" ;;
"--shell_version") shell_version="$2" ;;
"--ip_host") public_ip_host="$2" ;;
"--ip_timeout") public_ip_timeout="$2" ;;
"--ip_interface")
unset local_ip_interface
for arg in "$@"; do
case "$arg" in
"--ip_interface") ;;
"-"*) break ;;
*) local_ip_interface+=("$arg") ;;
esac
done
;;
"--song_format") song_format="$2" ;;
"--song_shorthand") song_shorthand="$2" ;;
"--music_player") music_player="$2" ;;
"--memory_percent") memory_percent="$2" ;;
"--memory_unit") memory_unit="$2" ;;
"--cpu_temp")
cpu_temp="$2"
[[ "$cpu_temp" == "on" ]] && cpu_temp="C"
;;
"--disk_subtitle") disk_subtitle="$2" ;;
"--disk_percent")  disk_percent="$2" ;;
"--disk_show")
unset disk_show
for arg in "$@"; do
case $arg in
"--disk_show") ;;
"-"*) break ;;
*) disk_show+=("$arg") ;;
esac
done
;;
"--disable")
for func in "$@"; do
case $func in
"--disable") continue ;;
"-"*) break ;;
*)
((bash_version >= 4)) && func="${func,,}"
unset -f "get_$func"
;;
esac
done
;;
"--colors")
unset colors
for arg in "$2" "$3" "$4" "$5" "$6" "$7"; do
case $arg in
"-"*) break ;;
*) colors+=("$arg") ;;
esac
done
colors+=(7 7 7 7 7 7)
;;
"--underline") underline_enabled="$2" ;;
"--underline_char") underline_char="$2" ;;
"--bold") bold="$2" ;;
"--separator") separator="$2" ;;
"--color_blocks") color_blocks="$2" ;;
"--block_range") block_range=("$2" "$3") ;;
"--block_width") block_width="$2" ;;
"--block_height") block_height="$2" ;;
"--col_offset") col_offset="$2" ;;
"--bar_char")
bar_char_elapsed="$2"
bar_char_total="$3"
;;
"--bar_border") bar_border="$2" ;;
"--bar_length") bar_length="$2" ;;
"--bar_colors")
bar_color_elapsed="$2"
bar_color_total="$3"
;;
"--memory_display") memory_display="$2" ;;
"--battery_display") battery_display="$2" ;;
"--disk_display") disk_display="$2" ;;
"--backend") image_backend="$2" ;;
"--source") image_source="$2" ;;
"--ascii" | "--caca" | "--catimg" | "--chafa" | "--jp2a" | "--iterm2" | "--off" |\
"--pot" | "--pixterm" | "--sixel" | "--termpix" | "--tycat" | "--w3m" | "--kitty" |\
"--ueberzug" | "--viu")
image_backend="${1/--}"
case $2 in
"-"* | "") ;;
*) image_source="$2" ;;
esac
;;
"--loop") image_loop="on" ;;
"--image_size" | "--size") image_size="$2" ;;
"--catimg_size") catimg_size="$2" ;;
"--crop_mode") crop_mode="$2" ;;
"--crop_offset") crop_offset="$2" ;;
"--xoffset") xoffset="$2" ;;
"--yoffset") yoffset="$2" ;;
"--background_color" | "--bg_color") background_color="$2" ;;
"--gap") gap="$2" ;;
"--clean")
[[ -d "$thumbnail_dir" ]] && rm -rf "$thumbnail_dir"
rm -rf "/Library/Caches/neofetch/"
rm -rf "/tmp/neofetch/"
exit
;;
"--ascii_colors")
unset ascii_colors
for arg in "$2" "$3" "$4" "$5" "$6" "$7"; do
case $arg in
"-"*) break ;;
*) ascii_colors+=("$arg")
esac
done
ascii_colors+=(7 7 7 7 7 7)
;;
"--ascii_distro")
image_backend="ascii"
ascii_distro="$2"
;;
"--ascii_bold") ascii_bold="$2" ;;
"--logo" | "-L")
image_backend="ascii"
print_info() { printf '\n'; }
;;
"--config")
case $2 in
"none" | "off" | "") ;;
*)
config_file="$(get_full_path "$2")"
get_user_config
;;
esac
;;
"--no_config") no_config="on" ;;
"--stdout") stdout="on" ;;
"-v") verbose="on" ;;
"--print_config") printf '%s\n' "$config"; exit ;;
"-vv") set -x; verbose="on" ;;
"--help") usage ;;
"--version")
printf '%s\n' "Neofetch $version"
exit 1
;;
"--gen-man")
help2man -n "A fast, highly customizable system info script" \
-N ./neofetch -o neofetch.1
exit 1
;;
"--json")
json="on"
unset -f get_title get_cols get_underline
printf '{\n'
print_info 2>/dev/null
printf '%s\n' "\"Version\": \"${version}\""
printf '}\n'
exit
;;
"--travis")
print_info() {
info title
info underline
info "OS" distro
info "Host" model
info "Kernel" kernel
info "Uptime" uptime
info "Packages" packages
info "Shell" shell
info "Resolution" resolution
info "DE" de
info "WM" wm
info "WM Theme" wm_theme
info "Theme" theme
info "Icons" icons
info "Terminal" term
info "Terminal Font" term_font
info "CPU" cpu
info "GPU" gpu
info "GPU Driver" gpu_driver
info "Memory" memory
info "Disk" disk
info "Battery" battery
info "Font" font
info "Song" song
info "Local IP" local_ip
info "Public IP" public_ip
info "Users" users
info cols
prin "prin"
prin "prin" "prin"
info uptime
info disk
}
refresh_rate="on"
shell_version="on"
memory_display="infobar"
disk_display="infobar"
cpu_temp="C"
mpc_args=()
printf '%s\n' "$kernel $icons $font $battery $locale ${mpc_args[*]}"
;;
esac
shift
done
}
get_simple() {
while [[ "$1" ]]; do
[[ "$(type -t "get_$1")" == "function" ]] && {
get_distro
stdout
simple=1
info "$1" "$1"
}
shift
done
((simple)) && exit
}
old_functions() {
get_line_break() { :; }
get_cpu_usage() { :; }
}
get_distro_ascii() {
#
case $(trim "$ascii_distro") in
"small"*)
set_colors 2 7
read -rd '' ascii_data <<'EOF'
${c1}  ;,           ,;
   ';,.-----.,;'
  ,'           ',
 /    O     O    \\
|                 |
'-----------------'
EOF
;;
*)
set_colors 2 7
read -rd '' ascii_data <<'EOF'
${c1}         -o          o-
          +hydNNNNdyh+
        +mMMMMMMMMMMMMm+
      `dMM${c2}m:${c1}NMMMMMMN${c2}:m${c1}MMd`
      hMMMMMMMMMMMMMMMMMMh
  ..  yyyyyyyyyyyyyyyyyyyy  ..
.mMMm`MMMMMMMMMMMMMMMMMMMM`mMMm.
:MMMM-MMMMMMMMMMMMMMMMMMMM-MMMM:
:MMMM-MMMMMMMMMMMMMMMMMMMM-MMMM:
:MMMM-MMMMMMMMMMMMMMMMMMMM-MMMM:
:MMMM-MMMMMMMMMMMMMMMMMMMM-MMMM:
-MMMM-MMMMMMMMMMMMMMMMMMMM-MMMM-
 +yy+ MMMMMMMMMMMMMMMMMMMM +yy+
      mMMMMMMMMMMMMMMMMMMm
      `/++MMMMh++hMMMM++/`
          MMMMo  oMMMM
          MMMMo  oMMMM
          oNMm-  -mMNs
EOF
;;
esac
[[ ${ascii_colors[0]} != distro ]] && {
color_text=off
set_colors "${ascii_colors[@]}"
}
}
main() {
cache_uname
get_os
eval "$config"
get_args "$@"
[[ $verbose != on ]] && exec 2>/dev/null
get_simple "$@"
get_distro
get_bold
get_distro_ascii
[[ $stdout == on ]] && stdout
[[ $TERM != minix && $stdout != on ]] && {
trap 'printf "\e[?25h\e[?7h"' EXIT
printf '\e[?25l\e[?7l'
}
image_backend
get_cache_dir
old_functions
print_info
dynamic_prompt
[[ $image_backend == *w3m* ]] && display_image
[[ $image_backend == *ueberzug* ]] && display_image
err "Neofetch command: $0 $*"
err "Neofetch version: $version"
[[ $verbose == on ]] && printf '%b\033[m' "$err" >&2
`--loop` was used, constantly redraw the image.
while [[ $image_loop == on && $image_backend == w3m ]]; do
display_image
sleep 1
done
return 0
}
main "$@"
